"""
Fingerprint-based exploitation module.

For each top molecule, generates ALL partner combinations and filters
using fast fingerprint similarity (Morgan + FCFP) to find the most
similar candidates to the winner molecule itself.

Based on auto_exploit_proven.py approach.

NOTE: rxn:5 uses tuple tracking (role, id) since roleB == roleC.
"""

import sqlite3
import os
import time
from typing import List, Tuple, Dict, Set, Optional
from dataclasses import dataclass, field
from functools import lru_cache

# Database connection timeout (seconds)
DB_TIMEOUT = 30

from tqdm import tqdm
from rdkit import Chem, DataStructs
from rdkit.Chem import rdFingerprintGenerator, Descriptors
from nova_ph2.combinatorial_db.reactions import get_smiles_from_reaction
from nova_ph2.utils.molecules import get_heavy_atom_count

# Fingerprint generators (same as auto_exploit_proven.py)
MORGAN_GEN = rdFingerprintGenerator.GetMorganGenerator(radius=2, fpSize=2048)
FCFP_GEN = rdFingerprintGenerator.GetMorganGenerator(
    radius=2, fpSize=2048,
    atomInvariantsGenerator=rdFingerprintGenerator.GetMorganFeatureAtomInvGen()
)

# Stage 1 thresholds (from auto_exploit_proven.py)
STAGE1_THRESHOLDS = {
    'tanimoto': 0.40,
    'fcfp': 0.40
}

# Stage 2 weights (3-metric composite)
STAGE2_WEIGHTS = {
    'tanimoto': 0.40,
    'fcfp': 0.35,
    'tversky': 0.25
}


@dataclass
class WinnerRef:
    """Reference molecule for similarity comparison."""
    name: str
    smiles: str
    mol: object = None
    morgan_fp: object = None
    fcfp_fp: object = None

    def __post_init__(self):
        if self.mol is None and self.smiles:
            self.mol = Chem.MolFromSmiles(self.smiles)
        if self.mol and self.morgan_fp is None:
            self.morgan_fp = MORGAN_GEN.GetFingerprint(self.mol)
        if self.mol and self.fcfp_fp is None:
            self.fcfp_fp = FCFP_GEN.GetFingerprint(self.mol)


@dataclass
class ExploitCandidate:
    """A candidate molecule from exploitation."""
    name: str
    smiles: str
    mol: object = None
    morgan_fp: object = None
    fcfp_fp: object = None
    metrics: Dict[str, float] = field(default_factory=dict)
    composite_score: float = 0.0
    winner_ref: str = ""


@lru_cache(maxsize=100000)
def get_smiles_cached(name: str) -> Optional[str]:
    """Cache SMILES lookups with retry for concurrent DB access."""
    for attempt in range(3):
        try:
            return get_smiles_from_reaction(name)
        except Exception as e:
            if "unable to open database" in str(e) or "database is locked" in str(e):
                if attempt < 2:
                    time.sleep(0.2)
                    continue
            return None
    return None


@lru_cache(maxsize=100000)
def get_mol_and_fps_cached(smiles: str) -> Optional[Tuple[object, object, object, int, int]]:
    """
    Cache molecule parsing and fingerprint computation.
    Returns: (mol, morgan_fp, fcfp_fp, heavy_atoms, rotatable_bonds) or None
    """
    if not smiles:
        return None
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            return None
        morgan_fp = MORGAN_GEN.GetFingerprint(mol)
        fcfp_fp = FCFP_GEN.GetFingerprint(mol)
        heavy_atoms = get_heavy_atom_count(smiles)  # Use same function as GA path
        rotatable = Descriptors.NumRotatableBonds(mol)
        return (mol, morgan_fp, fcfp_fp, heavy_atoms, rotatable)
    except:
        return None


@lru_cache(maxsize=10)
def get_reaction_info(rxn_id: int, db_path: str) -> Optional[Tuple[str, int, int, int]]:
    """Get reaction info from database with retry logic."""
    for attempt in range(3):
        try:
            conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True, timeout=DB_TIMEOUT)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT smarts, roleA, roleB, roleC FROM reactions WHERE rxn_id = ?",
                (str(rxn_id),)
            )
            row = cursor.fetchone()
            conn.close()
            return row if row else None
        except sqlite3.OperationalError:
            if attempt < 2:
                time.sleep(0.5)
            continue
        except:
            return None
    return None


@lru_cache(maxsize=10)
def load_molecules_by_role(role_mask: int, db_path: str) -> Tuple[Tuple[int, str], ...]:
    """Load all molecules matching a role mask with retry logic."""
    for attempt in range(3):
        try:
            conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True, timeout=DB_TIMEOUT)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT mol_id, smiles FROM molecules WHERE (role_mask & ?) = ?",
                (role_mask, role_mask)
            )
            results = tuple(cursor.fetchall())
            conn.close()
            return results
        except sqlite3.OperationalError:
            if attempt < 2:
                time.sleep(0.5)
            continue
        except:
            return ()
    return ()


def get_reactant_type(mol_id: int, roleA: int, roleB: int, db_path: str) -> Optional[str]:
    """Determine if a molecule is typeA or typeB based on role mask with retry logic."""
    for attempt in range(3):
        try:
            conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True, timeout=DB_TIMEOUT)
            cursor = conn.cursor()
            cursor.execute("SELECT role_mask FROM molecules WHERE mol_id = ?", (mol_id,))
            row = cursor.fetchone()
            conn.close()

            if not row:
                return None

            role_mask = row[0]
            is_A = (role_mask & roleA) == roleA
            is_B = (role_mask & roleB) == roleB

            if is_A and not is_B:
                return 'typeA'
            elif is_B and not is_A:
                return 'typeB'
            elif is_A and is_B:
                return 'typeA'  # Default to A if ambiguous
            return None
        except sqlite3.OperationalError:
            if attempt < 2:
                time.sleep(0.5)
            continue
        except:
            return None
    return None


def calc_metrics(cand_morgan, cand_fcfp, ref_morgan, ref_fcfp) -> Dict[str, float]:
    """Calculate similarity metrics."""
    tanimoto = DataStructs.TanimotoSimilarity(cand_morgan, ref_morgan)
    fcfp = DataStructs.TanimotoSimilarity(cand_fcfp, ref_fcfp)
    tversky = DataStructs.TverskySimilarity(cand_morgan, ref_morgan, 0.7, 0.3)
    return {'tanimoto': tanimoto, 'fcfp': fcfp, 'tversky': tversky}


def calc_composite_score(metrics: Dict[str, float]) -> float:
    """Calculate Stage 2 composite score."""
    return sum(STAGE2_WEIGHTS.get(k, 0) * v for k, v in metrics.items())


def exploit_single_reactant(
    reactant_id: int,
    reactant_type: str,
    winner: WinnerRef,
    rxn_id: int,
    db_path: str,
    roleA: int,
    roleB: int,
    limit: int = 50,
    avoid_names: Set[str] = None,
    min_heavy_atoms: int = 10,
    min_rotatable: int = 1,
    max_rotatable: int = 10
) -> Tuple[List[ExploitCandidate], Dict[str, int]]:
    """
    Exploit a single reactant using BULK fingerprint similarity (fast).
    Uses get_smiles_from_reaction for product generation (handles all rxn types).
    """
    if avoid_names is None:
        avoid_names = set()

    # Stats tracking
    stats = {
        'total': 0,
        'skipped_tested': 0,
        'errors': 0,
        'low_atoms': 0,
        'bad_rotatable': 0,
        'stage1_fail': 0,
        'stage1_pass': 0
    }

    # Load ALL partners (opposite role)
    if reactant_type == 'typeA':
        partners = load_molecules_by_role(roleB, db_path)
    else:
        partners = load_molecules_by_role(roleA, db_path)

    stats['total'] = len(partners)

    # PHASE 1: Build all reaction names and filter already seen
    print(f"      [Exploit] Phase 1: Building {len(partners)} reaction names...", flush=True)
    candidates_info = []  # [(partner_id, rxn_name), ...]
    for partner_id, partner_smiles in partners:
        if reactant_type == 'typeA':
            rxn_name = f"rxn:{rxn_id}:{reactant_id}:{partner_id}"
        else:
            rxn_name = f"rxn:{rxn_id}:{partner_id}:{reactant_id}"

        if rxn_name in avoid_names:
            stats['skipped_tested'] += 1
            continue
        candidates_info.append((partner_id, rxn_name))

    print(f"      [Exploit] Phase 1: {len(candidates_info)} candidates after skip filter", flush=True)

    # PHASE 2: Get product SMILES via get_smiles_from_reaction (handles all rxn types)
    print(f"      [Exploit] Phase 2: Generating products via reactions.py...", flush=True)
    valid_candidates = []  # [(rxn_name, smiles, mol, morgan_fp, fcfp_fp), ...]

    for partner_id, rxn_name in tqdm(candidates_info, desc="      Products", leave=False):
        # Use get_smiles_from_reaction - handles triazole, SMARTS, and cascade reactions
        product_smiles = get_smiles_cached(rxn_name)

        if not product_smiles:
            stats['errors'] += 1
            continue

        # Use cached mol + fingerprint computation
        mol_data = get_mol_and_fps_cached(product_smiles)
        if mol_data is None:
            stats['errors'] += 1
            continue

        mol, morgan_fp, fcfp_fp, heavy_atoms, rotatable = mol_data

        # Property filters
        if heavy_atoms < min_heavy_atoms:
            stats['low_atoms'] += 1
            continue

        if rotatable < min_rotatable or rotatable > max_rotatable:
            stats['bad_rotatable'] += 1
            continue

        valid_candidates.append((rxn_name, product_smiles, mol, morgan_fp, fcfp_fp))

    print(f"      [Exploit] Phase 2: {len(valid_candidates)} valid candidates", flush=True)

    if not valid_candidates:
        return [], stats

    # PHASE 3: BULK Tanimoto similarity
    print(f"      [Exploit] Phase 3: Bulk Tanimoto on {len(valid_candidates)} molecules...", flush=True)

    # Extract fingerprint lists for bulk operation
    morgan_fps = [c[3] for c in valid_candidates]
    fcfp_fps = [c[4] for c in valid_candidates]

    # Bulk similarity computation - MUCH faster than individual calls
    morgan_sims = DataStructs.BulkTanimotoSimilarity(winner.morgan_fp, morgan_fps)
    fcfp_sims = DataStructs.BulkTanimotoSimilarity(winner.fcfp_fp, fcfp_fps)

    # PHASE 4: Filter by Stage 1 thresholds
    stage1_passed = []
    for i, (rxn_name, product_smiles, mol, morgan_fp, fcfp_fp) in enumerate(valid_candidates):
        tanimoto = morgan_sims[i]
        fcfp = fcfp_sims[i]

        if tanimoto >= STAGE1_THRESHOLDS['tanimoto'] or fcfp >= STAGE1_THRESHOLDS['fcfp']:
            # Compute full metrics for passed candidates
            tversky = DataStructs.TverskySimilarity(morgan_fp, winner.morgan_fp, 0.7, 0.3)
            metrics = {'tanimoto': tanimoto, 'fcfp': fcfp, 'tversky': tversky}

            cand = ExploitCandidate(
                name=rxn_name,
                smiles=product_smiles,
                mol=mol,
                morgan_fp=morgan_fp,
                fcfp_fp=fcfp_fp,
                metrics=metrics,
                composite_score=calc_composite_score(metrics),
                winner_ref=winner.name
            )
            stage1_passed.append(cand)
            stats['stage1_pass'] += 1
        else:
            stats['stage1_fail'] += 1

    # Stage 2: Sort by composite and take top limit
    stage1_passed.sort(key=lambda x: x.composite_score, reverse=True)
    return stage1_passed[:limit], stats


def exploit_single_variation_3comp(
    fixed_ids: Tuple[int, int],
    vary_role: str,
    winner: WinnerRef,
    rxn_id: int,
    db_path: str,
    roleA: int,
    roleB: int,
    roleC: int,
    limit: int = 50,
    avoid_names: Set[str] = None,
    min_heavy_atoms: int = 10,
    min_rotatable: int = 1,
    max_rotatable: int = 10
) -> Tuple[List[ExploitCandidate], Dict[str, int]]:
    """
    Exploit 3-component reaction by varying one component.
    fixed_ids: (id1, id2) - the two fixed reactant IDs
    vary_role: 'A', 'B', or 'C' - which role to vary
    """
    if avoid_names is None:
        avoid_names = set()

    stats = {
        'total': 0, 'skipped_tested': 0, 'errors': 0,
        'low_atoms': 0, 'bad_rotatable': 0, 'stage1_fail': 0, 'stage1_pass': 0
    }

    # Load partners for the role we're varying
    if vary_role == 'A':
        partners = load_molecules_by_role(roleA, db_path)
    elif vary_role == 'B':
        partners = load_molecules_by_role(roleB, db_path)
    else:  # 'C'
        partners = load_molecules_by_role(roleC, db_path)

    stats['total'] = len(partners)
    print(f"      [Exploit] Varying {vary_role}: {len(partners)} partners to try", flush=True)

    # Build reaction names based on which role we're varying
    # Format: rxn:X:A:B:C
    candidates_info = []
    for partner_id, partner_smiles in partners:
        if vary_role == 'A':
            rxn_name = f"rxn:{rxn_id}:{partner_id}:{fixed_ids[0]}:{fixed_ids[1]}"
        elif vary_role == 'B':
            rxn_name = f"rxn:{rxn_id}:{fixed_ids[0]}:{partner_id}:{fixed_ids[1]}"
        else:  # 'C'
            rxn_name = f"rxn:{rxn_id}:{fixed_ids[0]}:{fixed_ids[1]}:{partner_id}"

        if rxn_name in avoid_names:
            stats['skipped_tested'] += 1
            continue
        candidates_info.append((partner_id, rxn_name))

    print(f"      [Exploit] {len(candidates_info)} candidates after skip filter", flush=True)

    # Generate products and compute fingerprints
    valid_candidates = []
    for partner_id, rxn_name in tqdm(candidates_info, desc=f"      Vary {vary_role}", leave=False):
        product_smiles = get_smiles_cached(rxn_name)
        if not product_smiles:
            stats['errors'] += 1
            continue

        mol_data = get_mol_and_fps_cached(product_smiles)
        if mol_data is None:
            stats['errors'] += 1
            continue

        mol, morgan_fp, fcfp_fp, heavy_atoms, rotatable = mol_data

        if heavy_atoms < min_heavy_atoms:
            stats['low_atoms'] += 1
            continue
        if rotatable < min_rotatable or rotatable > max_rotatable:
            stats['bad_rotatable'] += 1
            continue

        valid_candidates.append((rxn_name, product_smiles, mol, morgan_fp, fcfp_fp))

    if not valid_candidates:
        return [], stats

    # Bulk similarity
    morgan_fps = [c[3] for c in valid_candidates]
    fcfp_fps = [c[4] for c in valid_candidates]
    morgan_sims = DataStructs.BulkTanimotoSimilarity(winner.morgan_fp, morgan_fps)
    fcfp_sims = DataStructs.BulkTanimotoSimilarity(winner.fcfp_fp, fcfp_fps)

    # Stage 1 filter
    stage1_passed = []
    for i, (rxn_name, product_smiles, mol, morgan_fp, fcfp_fp) in enumerate(valid_candidates):
        tanimoto = morgan_sims[i]
        fcfp = fcfp_sims[i]

        if tanimoto >= STAGE1_THRESHOLDS['tanimoto'] or fcfp >= STAGE1_THRESHOLDS['fcfp']:
            tversky = DataStructs.TverskySimilarity(morgan_fp, winner.morgan_fp, 0.7, 0.3)
            metrics = {'tanimoto': tanimoto, 'fcfp': fcfp, 'tversky': tversky}
            cand = ExploitCandidate(
                name=rxn_name, smiles=product_smiles, mol=mol,
                morgan_fp=morgan_fp, fcfp_fp=fcfp_fp,
                metrics=metrics, composite_score=calc_composite_score(metrics),
                winner_ref=winner.name
            )
            stage1_passed.append(cand)
            stats['stage1_pass'] += 1
        else:
            stats['stage1_fail'] += 1

    stage1_passed.sort(key=lambda x: x.composite_score, reverse=True)
    return stage1_passed[:limit], stats


def exploit_top_molecules_3comp(
    top_molecules: List[Dict],
    db_path: str,
    rxn_id: int,
    roleA: int,
    roleB: int,
    roleC: int,
    top_n: int = 5,
    limit_per_reactant: int = 50,
    avoid_names: Set[str] = None,
    exploited_reactants: Set = None,
    min_heavy_atoms: int = 10,
    min_rotatable: int = 1,
    max_rotatable: int = 10,
    verbose: bool = True
) -> Tuple[List[Dict], Dict[str, any]]:
    """
    Exploit 3-component reactions (rxn:3, rxn:5).
    For each winner rxn:X:A:B:C, we vary one component at a time:
      - Fix B,C -> vary A
      - Fix A,C -> vary B
      - Fix A,B -> vary C

    NOTE: rxn:5 uses tuple tracking (role, id) since roleB == roleC.
    """
    if avoid_names is None:
        avoid_names = set()
    if exploited_reactants is None:
        exploited_reactants = set()

    local_avoid = set(avoid_names)

    # Track unique (A,B,C) tuples to avoid re-exploiting
    exploited_tuples = set()

    # rxn:5 uses tuple tracking (role, id) since roleB == roleC
    use_tuple_tracking = (rxn_id == 5)

    all_candidates = []
    summary = {
        'molecules_processed': 0,
        'variations_exploited': 0,
        'total_partners_checked': 0,
        'total_stage1_pass': 0,
        'total_candidates': 0,
        'exploited_reactant_ids': set()
    }

    for mol_info in top_molecules[:top_n]:
        name = mol_info.get("name", "")
        smiles = mol_info.get("smiles", "")

        if not name or not smiles:
            continue

        # Parse 3-component name: rxn:X:A:B:C
        parts = name.split(":")
        if len(parts) != 5:
            continue

        try:
            id_A = int(parts[2])
            id_B = int(parts[3])
            id_C = int(parts[4])
        except (ValueError, IndexError):
            continue

        winner = WinnerRef(name=name, smiles=smiles)
        if winner.mol is None:
            continue

        summary['molecules_processed'] += 1

        if verbose:
            print(f"[Exploit] 3-comp: {name}", flush=True)

        # Vary A (fix B, C)
        tuple_key = ('A', id_B, id_C)
        check_key_A = ('A', id_A) if use_tuple_tracking else id_A
        if tuple_key not in exploited_tuples and check_key_A not in exploited_reactants:
            if verbose:
                print(f"  [Exploit] Varying A, fixing B={id_B}, C={id_C}", flush=True)
            candidates, stats = exploit_single_variation_3comp(
                fixed_ids=(id_B, id_C), vary_role='A', winner=winner,
                rxn_id=rxn_id, db_path=db_path,
                roleA=roleA, roleB=roleB, roleC=roleC,
                limit=limit_per_reactant, avoid_names=local_avoid,
                min_heavy_atoms=min_heavy_atoms,
                min_rotatable=min_rotatable, max_rotatable=max_rotatable
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['total_partners_checked'] += stats['total']
            summary['total_stage1_pass'] += stats['stage1_pass']
            summary['exploited_reactant_ids'].add(('A', id_A) if use_tuple_tracking else id_A)
            exploited_tuples.add(tuple_key)
            for c in candidates:
                local_avoid.add(c.name)
            if verbose:
                print(f"  [Exploit]   -> {len(candidates)} candidates", flush=True)

        # Vary B (fix A, C)
        tuple_key = ('B', id_A, id_C)
        check_key_B = ('B', id_B) if use_tuple_tracking else id_B
        if tuple_key not in exploited_tuples and check_key_B not in exploited_reactants:
            if verbose:
                print(f"  [Exploit] Varying B, fixing A={id_A}, C={id_C}", flush=True)
            candidates, stats = exploit_single_variation_3comp(
                fixed_ids=(id_A, id_C), vary_role='B', winner=winner,
                rxn_id=rxn_id, db_path=db_path,
                roleA=roleA, roleB=roleB, roleC=roleC,
                limit=limit_per_reactant, avoid_names=local_avoid,
                min_heavy_atoms=min_heavy_atoms,
                min_rotatable=min_rotatable, max_rotatable=max_rotatable
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['total_partners_checked'] += stats['total']
            summary['total_stage1_pass'] += stats['stage1_pass']
            summary['exploited_reactant_ids'].add(('B', id_B) if use_tuple_tracking else id_B)
            exploited_tuples.add(tuple_key)
            for c in candidates:
                local_avoid.add(c.name)
            if verbose:
                print(f"  [Exploit]   -> {len(candidates)} candidates", flush=True)

        # Vary C (fix A, B)
        tuple_key = ('C', id_A, id_B)
        check_key_C = ('C', id_C) if use_tuple_tracking else id_C
        if tuple_key not in exploited_tuples and check_key_C not in exploited_reactants:
            if verbose:
                print(f"  [Exploit] Varying C, fixing A={id_A}, B={id_B}", flush=True)
            candidates, stats = exploit_single_variation_3comp(
                fixed_ids=(id_A, id_B), vary_role='C', winner=winner,
                rxn_id=rxn_id, db_path=db_path,
                roleA=roleA, roleB=roleB, roleC=roleC,
                limit=limit_per_reactant, avoid_names=local_avoid,
                min_heavy_atoms=min_heavy_atoms,
                min_rotatable=min_rotatable, max_rotatable=max_rotatable
            )
            all_candidates.extend(candidates)
            summary['variations_exploited'] += 1
            summary['total_partners_checked'] += stats['total']
            summary['total_stage1_pass'] += stats['stage1_pass']
            summary['exploited_reactant_ids'].add(('C', id_C) if use_tuple_tracking else id_C)
            exploited_tuples.add(tuple_key)
            for c in candidates:
                local_avoid.add(c.name)
            if verbose:
                print(f"  [Exploit]   -> {len(candidates)} candidates", flush=True)

    summary['total_candidates'] = len(all_candidates)

    # Convert to dicts
    results = []
    for c in all_candidates:
        results.append({
            "name": c.name,
            "smiles": c.smiles,
            "composite_score": c.composite_score,
            "winner_ref": c.winner_ref,
            "metrics": c.metrics
        })

    if verbose:
        print(f"[Exploit] 3-comp Summary: {summary['molecules_processed']} molecules, "
              f"{summary['variations_exploited']} variations, "
              f"{summary['total_candidates']} candidates", flush=True)

    return results, summary


def exploit_top_molecules(
    top_molecules: List[Dict],
    db_path: str,
    rxn_id: int,
    top_n: int = 5,
    limit_per_reactant: int = 50,
    avoid_names: Set[str] = None,
    exploited_reactants: Set = None,
    min_heavy_atoms: int = 10,
    min_rotatable: int = 1,
    max_rotatable: int = 10,
    verbose: bool = True
) -> Tuple[List[Dict], Dict[str, any]]:
    """
    Main exploitation function - exploits UNIQUE reactants only.
    Skips reactants that have already been exploited.
    """
    if avoid_names is None:
        avoid_names = set()
    if exploited_reactants is None:
        exploited_reactants = set()

    # Make a local copy to avoid modifying the original set
    local_avoid = set(avoid_names)

    # Get reaction info
    rxn_info = get_reaction_info(rxn_id, db_path)
    if not rxn_info:
        if verbose:
            print(f"[Exploit] ERROR: Could not get reaction info for rxn:{rxn_id}", flush=True)
        return [], {}

    smarts, roleA, roleB, roleC = rxn_info

    # Check if this is a 3-component reaction
    is_three_component = roleC is not None and roleC != 0
    if is_three_component:
        if verbose:
            print(f"[Exploit] rxn:{rxn_id} is a 3-component reaction (roleC={roleC})", flush=True)
        return exploit_top_molecules_3comp(
            top_molecules=top_molecules,
            db_path=db_path,
            rxn_id=rxn_id,
            roleA=roleA,
            roleB=roleB,
            roleC=roleC,
            top_n=top_n,
            limit_per_reactant=limit_per_reactant,
            avoid_names=avoid_names,
            exploited_reactants=exploited_reactants,
            min_heavy_atoms=min_heavy_atoms,
            min_rotatable=min_rotatable,
            max_rotatable=max_rotatable,
            verbose=verbose
        )

    # STEP 1: Collect unique reactants from top molecules
    unique_reactants = {}  # {reactant_id: {'type': str, 'winner': WinnerRef}}

    for mol_info in top_molecules[:top_n]:
        name = mol_info.get("name", "")
        smiles = mol_info.get("smiles", "")

        if not name or not smiles:
            continue

        parts = name.split(":")
        if len(parts) < 4:
            continue

        try:
            rxn_type = int(parts[1])
            id_A = int(parts[2])
            id_B = int(parts[3])
        except (ValueError, IndexError):
            continue

        # Create winner reference for this molecule
        winner = WinnerRef(name=name, smiles=smiles)
        if winner.mol is None:
            continue

        # Get reactant types
        type_A = get_reactant_type(id_A, roleA, roleB, db_path)
        type_B = get_reactant_type(id_B, roleA, roleB, db_path)

        # Add to unique reactants (only if not already added AND not already exploited)
        if type_A and id_A not in unique_reactants and id_A not in exploited_reactants:
            unique_reactants[id_A] = {'type': type_A, 'winner': winner}
        if type_B and id_B not in unique_reactants and id_B not in exploited_reactants:
            unique_reactants[id_B] = {'type': type_B, 'winner': winner}

    if verbose:
        print(f"[Exploit] Found {len(unique_reactants)} unique reactants from {top_n} molecules (skipped {len(exploited_reactants)} already exploited)", flush=True)

    # STEP 2: Exploit each unique reactant ONCE
    all_candidates = []
    summary = {
        'molecules_processed': top_n,
        'unique_reactants': len(unique_reactants),
        'reactants_exploited': 0,
        'total_partners_checked': 0,
        'total_stage1_pass': 0,
        'total_candidates': 0,
        'exploited_reactant_ids': set()
    }

    for reactant_id, info in unique_reactants.items():
        reactant_type = info['type']
        winner = info['winner']

        if verbose:
            print(f"[Exploit] Exploiting {reactant_type} {reactant_id} (ref: {winner.name})", flush=True)

        candidates, stats = exploit_single_reactant(
            reactant_id=reactant_id,
            reactant_type=reactant_type,
            winner=winner,
            rxn_id=rxn_id,
            db_path=db_path,
            roleA=roleA,
            roleB=roleB,
            limit=limit_per_reactant,
            avoid_names=local_avoid,
            min_heavy_atoms=min_heavy_atoms,
            min_rotatable=min_rotatable,
            max_rotatable=max_rotatable
        )

        all_candidates.extend(candidates)
        summary['reactants_exploited'] += 1
        summary['total_partners_checked'] += stats['total']
        summary['total_stage1_pass'] += stats['stage1_pass']
        summary['exploited_reactant_ids'].add(reactant_id)

        if verbose:
            print(f"[Exploit]   {stats['total']:,} partners -> {stats['stage1_pass']} stage1 -> {len(candidates)} kept", flush=True)
            print(f"[Exploit]   (skipped={stats['skipped_tested']}, errors={stats['errors']}, "
                  f"atoms={stats['low_atoms']}, rotatable={stats['bad_rotatable']}, "
                  f"sim_fail={stats['stage1_fail']})", flush=True)

        # Add candidates to local_avoid to prevent duplicates across reactants
        for c in candidates:
            local_avoid.add(c.name)

    summary['total_candidates'] = len(all_candidates)

    # Convert to simple dicts for return
    results = []
    for c in all_candidates:
        results.append({
            "name": c.name,
            "smiles": c.smiles,
            "composite_score": c.composite_score,
            "winner_ref": c.winner_ref,
            "metrics": c.metrics
        })

    if verbose:
        print(f"[Exploit] Summary: {summary['unique_reactants']} unique reactants, "
              f"{summary['reactants_exploited']} exploited, "
              f"{summary['total_partners_checked']:,} partners checked, "
              f"{summary['total_stage1_pass']} stage1 pass, "
              f"{summary['total_candidates']} candidates", flush=True)

    return results, summary


def run_exploit(
    top_molecules: List[Dict],
    db_path: str,
    rxn_id: int,
    top_n: int = 5,
    limit_per_reactant: int = 50,
    avoid_names: Set[str] = None,
    exploited_reactants: Set = None,
    min_heavy_atoms: int = 10,
    min_rotatable: int = 1,
    max_rotatable: int = 10,
    verbose: bool = True
) -> Tuple[List[Dict], Dict[str, any]]:
    """
    Main entry point for exploitation.
    """
    return exploit_top_molecules(
        top_molecules=top_molecules,
        db_path=db_path,
        rxn_id=rxn_id,
        top_n=top_n,
        limit_per_reactant=limit_per_reactant,
        avoid_names=avoid_names,
        exploited_reactants=exploited_reactants,
        min_heavy_atoms=min_heavy_atoms,
        min_rotatable=min_rotatable,
        max_rotatable=max_rotatable,
        verbose=verbose
    )
